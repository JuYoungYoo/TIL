# 1.카프카란 무엇인가?
> 대용량, 대규모 메시지 데이터 빠르게 처리하기 위한 목적으로 개발된 __메시징 플랫폼(카프카)__
링크드인(LinkedIn)에서 시작 아파치 공신 오픈소스로 공개(2011)
빅데이터 ㄹ분석 ㄹ시 여러 스토리지, 분석 시스템에 연결하기 위한 도구로 많이 사용되고 있음

## 탄생배경
end-to-end 연결 방식의 아키텍처에 대한 문제점으로 시작
__문제점__
1. 실시간 트랜잭션(OLTP) 처리와 비동기 처리가 동시에 이뤄지지만 통합된 전송영역이 없어 복잡도 증가   
(문제/결과 -> 문제점을 발견하고 조치하기 위해 관련 여러 데이터 시스템 확인 필요, 장애, 운영체제 업그레이드,    
  하드웨어 증설등에도 준비시간 소요)   
2. 데이터 파이프란인 관리 어려움
많은 데이터 시스템들(실시간 트랜잭션 데이터베이스, 하둡, 모니터링 시스템, 키-값 저장소...)이
모두 다른 방식으로 파이프라인을 만들고 유지하고 있음
(문제/결과 -> 데이터 분석을 위해 서로 연결이 필요할 경우 데이터 포맷,처리방법이 달라 파이프라인 확장에 어려움)

__결과__
- 복잡도 증가
- 파이프라인 파편화
- 개발 지연
- 데이터 신뢰성 저하

__목표__
- 프로듀서, 컨슈머 분리
- 메시징 시스템과 같이 영구 메시지 데이터를 여러 컨슈머에게 허용
- 높은 처리량을 위한 메시지 최적화
- 데이터가 증가함에 따라 스케일아웃이 가능한 시스템

## 동작원리
기본적으로 메시징 서버로 동작
```
[Pub/Sub 모델]
`비동기 메시징 전송 방식`이다.
중앙에 메시징 시스템 서버를 두고 메시지를 보내고, 받는 형태의 통신을 말함.
메시지는 수신자가 정해져 있지 않은 상태로 발행(publish)한다.
메시지는 구독(subscribe)을 신청한 수신자만이 정해진 메시지를 받을 수 있다.
장점 : 높은 확장성

publisher, producer : 메시지를 보내는 측
subscriber, consumer : 메시지를 가져가는 측
```

### 일반적인 통신 vs 펍/섭모델 통신 비교
#### 일반적인 통신
> API 호출로 바로 통신하는 방신
프로듀서가 컨슈머에게 직접 전달하는 구조

__장점__    
- 빠른 전송 속도
- 전송 결과를 빠르게 알 수 있다   
__단점__    
- 메시지를 보내는 쪽에서 대기처리 등 개별적 처리 필요 (장애발생의 요인)
- 통신 참여하는 개체가 증가 시 (위의)동일한 작업이 필요하여 `확장성 저하`

#### 펍/섭 모델
> 프로듀서와 컨슈머 사이에 중간의 메세징 시스템 존재
모든 메시지는 메세징 시스템을 통해 받고, 전달한다
1. publisher -> messaging system 메세지 전달 : 메시지 데이터와 수신처 ID 포함
2. messaging system의 교환기(exchanger) : 메시지의 수신처 ID 확인 후 수신자 큐에 전달
3. consumer : 자신의 큐 모니터링 중 메시지 전달 시 컨슘한다

__장점__    
- 수신 불능 상태이며 메시징 시스템 살아있을 경우, 프로듀서에서 전달된 메시지가 유실되지 않는다.
consumer가 수신 불가 상태에서 회복되었을 경우 정상작동
- 메세징 시스템을 중심으로 연결하여 1:N 통신을 함. `확장성에 용이함`
- 메세지 유실 우려가 없음
__단점__
- 직접 통신이 아니기 때문에, 코드 복잡도 증가(메세지 정확하게 전달되었는지 확인하는 코드 필요)
- 메세지 전달 속도가 일반 통신에 비해 느림
- 기존 메세징 시스템은 신뢰성을 중점을 두고 개발되어 속도,용량관련 성능은 고려되지 않음

### 카프카
>
1. pub/sub model 단점 보안
- 메시지 교환 정달의 신뢰성 관리`메세지관리`를 컨슈머, 프로듀서에게 이관
- 부하가 많이 걸리는 교환기 기능 컨슈머에서 생성
메시징 시스템은 기존 작업량을 줄이고, 메시징 전달 성능에 집중하여 `고성능 메시징 시스템`으로 성장
2. __비동기 시스템__
3. 메세지는 토픽(`topic`)이라는 식별자를 이용해 토픽단위로 저장
4. 비동기 기반으로 메세지 전달하는 `메세지 큐 솔루션` ex) RabbitMQ ..

#### 동작 방식
1. producer -> kafka : 메세지 전송
2. kafka에 consumer queue(=`topic`)에 도착하여 저장
3. consumer는 메세지를 가져감

#### 특징
1. 컨슈머, 프로듀서 분리
__펍/섭 방식 적용__ 하여 보내는 역할, 받는역할 분리    
- 구조의 __단순화__
- 다른 서비스 통신에서 문제가 생길 경우, 연쇄작용으로 다른 서버도 지연 이슈가 발생 할 수 있음
- 각자 역할리 완벽하게 분리되어 연쇄작용이 발생할 위험이 적음
- 서버 추가에 대한 부담감 저하

2. 멀티 프로듀서, 멀티 컨슈머
하나의 토픽에 여러 프로듀서, 컨슈머 접근 가능하다     
프로듀서 : 1개 이상의 토픽으로 메시지 전달   
컨슈머 : 1개 이상의 토픽으로부터 메시지 가져옴     
__장점__    
데이터 분석, 처리 프로세스에서 _하나의 데이터를 다양한 용도로 사용하기에 용이함__   

3. 디스크에 메시지 저장
디스크에 메시지를 저장하고 유지     
(참고: 일반적인 메시징 시스템은 컨슈머가 메시지 컨슘하면 해당 메시지를 바로 삭제)
- 멀티 컨슈머가 가능한 이유
- 컨슈머 서버 장애 시, 메시지 유실 될 우려가 없기 때문에 복구에 용이함

4. 확장성
하나의 카프카 클러스터는 3개의 `브로커`로 시작(default)    
__수십대의 브로커로 확장 가능.__        
확장 작업은 __서비스의 중단없이 온라인 상태에서 작업 가능__   

5. 높은 성능
내부적으로 분산처리, 배치 처리등 다양한 기법 사용하고 있음     

#### 용어 정리
- 카프카(kafka, kafka cluster): 아파치 프로젝트 애플리케이션. 클러스터 구성 가능
- 브로커(broker): 카프카 애플리케이션이 설치되어 있는 서버 or 노드
- 토픽(topic): 프로듀서, 컨슈머들이 카프카로 보낸 메시지를 구분하기 위한 네임으로 사용
- __파티션(partition)__: 병렬처리가 가능하도록 토픽을 나눌수 있음.
많은 양의 메시지 처리를 위해 파티션의 수를 증가시킬 수 있다.
- 프로듀서(producer): 메시지를 생산하여 브로커의 토픽이름으로 보내는 서버 또는 애플리케이션
- 컨슈머(consumer): 브로커의 토픽이름으로 저장된 메시지를 가져가는 서버 또는 애플리케이션

## 1.4 카프카의 확장과 발전
`서비스 기반 아키텍처(SOA, Service Oriented Architecture)`의 핵심요소 중
하나인 `엔터프라이즈 서비스 버스(ESB, Enterprise Service Bus)`를 쉽게 구현 가능하게 됨

```
SOA는 업무를서비스 단위로 쪼개고 각 서비스 간의 통신은 ESB를 통해 연결한다는 철학
```
### ESB 특징
- 다양한 시스템과 연동하기 위한 __멀티 프로토콜과 데이터 타입 지원__
- __느슨한 결합(loosely coupled)__ 를 위한 메시지 큐 지원
- 정기적으로 데이터를 가져오는 (polling)대신 __이벤트 기반(event-driven) 통신 지향__

카프카를 통해 ESB, 메시지 버스, 이벤트 버스등과 같이 데이터 흐름을 중앙에서 관리하는 사례가 증가하고 있음.   
---
# 2. 카프카 설치
### 주키퍼
> 코디네이션 서비스
분산 애플리케이션을 위한 코디네이션 시스템
분산 애플리케이션이 안정적인 서비스가 가능하도록 분산되어 있는 각 애플리케이션의 정보를 중앙에 집중하고
`구성관리`, `그룹관리 네이밍`, `동기화`등의 서비스를 제공한다.

주키퍼는 여러대의 클러스터(앙상블)로 구성   
분산 애플리케이션이 각각 클라이언트가되어 주키퍼 서버들과 커넥션을 맺고, 상태 정보를 주고 받음 (동기화)   
상태 정보는 주키퍼의 지노드(znode)에 key-value 형태로 저장 (그냥 파일이며, 계층형 구조로 되어있음)    
지노드는 데이터 변경 등에 대한 유효성 검사 등을 위해 `버전 번호 관리`함 (버전은 데이터 변경 시 버전이 올라간다)    
주키퍼에 저장되는 데이터는 메모리에 저장하고, 처리량이 매우 크고 속도 또한 빠름    
클러스터는 항상 홀수이며, 과반수 이상 유지되어야함 (미만일 경우 장애발생)    
